indices_to_consider <- which(apply(topics_theta[indices,],1, function(x) which.max(x))==clus);
new_genes <- gene_names_mat_poisson[clus,indices_to_consider];
lapply(1:length(new_genes), function(n) out[grep(as.character(new_genes[n]), out$query),])
lapply(1:length(gene_names_mat_poisson[clus,]
), function(n) out[grep(as.character(gene_names_mat_poisson[clus,n]
), out$query), ])
clus <- 2
gene_names_mat_poisson[clus,]
indices <- sapply(1:length(gene_names_mat_poisson[clus,]), function(n) grep(gene_names_mat_poisson[clus,n],gene_names))
indices_to_consider <- which(apply(topics_theta[indices,],1, function(x) which.max(x))==clus);
new_genes <- gene_names_mat_poisson[clus,indices_to_consider];
lapply(1:length(new_genes), function(n) out[grep(as.character(new_genes[n]), out$query),])
lapply(1:length(gene_names_mat_poisson[clus,]
), function(n) out[grep(as.character(gene_names_mat_poisson[clus,n]
), out$query), ])
clus <- 1
gene_names_mat_poisson[clus,]
indices <- sapply(1:length(gene_names_mat_poisson[clus,]), function(n) grep(gene_names_mat_poisson[clus,n],gene_names))
indices_to_consider <- which(apply(topics_theta[indices,],1, function(x) which.max(x))==clus);
new_genes <- gene_names_mat_poisson[clus,indices_to_consider];
lapply(1:length(new_genes), function(n) out[grep(as.character(new_genes[n]), out$query),])
lapply(1:length(gene_names_mat_poisson[clus,]
), function(n) out[grep(as.character(gene_names_mat_poisson[clus,n]
), out$query), ])
Inf
Inf > Inf
-Inf > -Inf
data= data.frame(fread('/Users/kushal/Documents/gtex-viz/gtex.Kushal/data/gtex_thinned_version_1.txt'))[,-1];
samples_id=read.table("/Users/kushal/Documents/gtex-viz/gtex.Kushal/data/samples_id.txt");
test_indices <- which(samples_id[,3]=='Heart - Left Ventricle' | samples_id[,3]=='Muscle - Skeletal');
test_indices_sampled <- sample(test_indices, 50, replace=FALSE);
samples <- data[,test_indices_sampled];
col = c(rgb(seq(0,1,length=15),1,seq(0,1,length=15)), rgb(1,seq(1,0,length=15),seq(1,0,length=15)));
library(data.table)
library(limma)
library(philentropy)
library(maptpx)
data= data.frame(fread('/Users/kushal/Documents/gtex-viz/gtex.Kushal/data/gtex_thinned_version_1.txt'))[,-1];
samples_id=read.table("/Users/kushal/Documents/gtex-viz/gtex.Kushal/data/samples_id.txt");
test_indices <- which(samples_id[,3]=='Heart - Left Ventricle' | samples_id[,3]=='Muscle - Skeletal');
test_indices_sampled <- sample(test_indices, 50, replace=FALSE);
samples <- data[,test_indices_sampled];
col = c(rgb(seq(0,1,length=15),1,seq(0,1,length=15)), rgb(1,seq(1,0,length=15),seq(1,0,length=15)));
png(filename="../plots/heart_muscle_hierarchical_heatmap_average.png")
heatmap.2(distance(t(samples),method="euclidean"),labCol=samples_id[test_indices_sampled,3],labRow=samples_id[test_indices_sampled,3],scale="none", trace="none", distfun=function(x) dist(x,method="euclidean"), col=col, hclustfun = function(x) hclust(x,method="average"));
dev.off()
librray(gplots)
library(gplots)
png(filename="../plots/heart_muscle_hierarchical_heatmap_average.png")
heatmap.2(distance(t(samples),method="euclidean"),labCol=samples_id[test_indices_sampled,3],labRow=samples_id[test_indices_sampled,3],scale="none", trace="none", distfun=function(x) dist(x,method="euclidean"), col=col, hclustfun = function(x) hclust(x,method="average"));
dev.off()
png(filename="../plots/heart_muscle_hierarchical_heatmap_complete.png")
heatmap.2(distance(t(samples),method="euclidean"),labCol=samples_id[test_indices_sampled,3],labRow=samples_id[test_indices_sampled,3],scale="none", trace="none", distfun=function(x) dist(x,method="euclidean"), col=col, hclustfun = function(x) hclust(x,method="complete"));
dev.off()
install_github('kkdey/tmcmcR')
library(devtools)
library(devtools)
install_github('kkdey/tmcmcR')
library(tmcmcR)
install_github('kkdey/tmcmcR')
library(tmcmcR)
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
install_github('kkdey/tmcmcR')
library(tmcmcR)
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
install_github('kkdey/tmcmcR')
library(tmcmcR)
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
base=rnorm(d,0,1);
library(mcmc)
d=50;  ##  dimension of the simulated variable
nsamples=10000;##  sample size in eahc iteration/ replication
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mattingly_matrix <- 1000*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x,mu_target, Sigma_target)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
install_github('kkdey/tmcmcR')
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
library(tmcmcR)
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
install_github('kkdey/tmcmcR')
library(tmcmcR)
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
install_github('kkdey/tmcmcR')
library(tmcmcR)
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
install_github('kkdey/tmcmcR')
library(tmcmcR)
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
G <- 500;
num_cells <- 400;
amp_genes <- rep(10, G);
phi_genes <- runif(G, 0, 2*pi)
sigma_genes <- rchisq(G, 4);
cell_times_sim <- sample(seq(0,2*pi, 2*pi/(num_cells-1)), num_cells, replace=FALSE);
source('~/Documents/singleCell-method/project/R/cell_order/cell_cycle_sim.R')
G <- 500;
num_cells <- 400;
amp_genes <- rep(10, G);
phi_genes <- runif(G, 0, 2*pi)
sigma_genes <- rchisq(G, 4);
cell_times_sim <- sample(seq(0,2*pi, 2*pi/(num_cells-1)), num_cells, replace=FALSE);
cycle_data <- sim_sinusoidal_cycle(G, amp_genes, phi_genes, sigma_genes, cell_times_sim);
celltime_levels <- 100;
atan3 <- function(beta2, beta1)
{
if (beta1 > 0)
v <- atan(beta2/beta1);
if(beta2 >=0 & beta1 <0)
v <- pi + atan(beta2/beta1);
if(beta2 <0 & beta1 <0)
v <- -pi + atan(beta2/beta1);
if(beta2 >0 & beta1==0)
v <- pi/2;
if(beta2 <0 & beta1==0)
v <- - (pi/2);
if (v < 0)
v <- v + 2*pi;
# print(v)
#  print(beta1)
#  print(beta2)
return(v)
}
G <- dim(cycle_data)[2];
numcells <- dim(cycle_data)[1];
celltimes_choice <- seq(0, 2*pi, 2*pi/(celltime_levels-1));
cell_times_init <- sample(celltimes_choice, numcells, replace=TRUE);
cell_times_iter <- cell_times_init;
G <- dim(cycle_data)[2];
numcells <- dim(cycle_data)[1];
sigma <- array(0,G);
amp <- array(0,G); phi <- array(0,G);
lmfit_list <- parallel::mclapply(1:G, function(g)
{
fit <- lm(cycle_data[,g]  ~ sin(cell_times_iter) + cos(cell_times_iter) -1);
sigma[g] <- sd(fit$residuals);
beta1 <- fit$coefficients[1];
beta2 <- fit$coefficients[2];
if(beta1==0 & beta2==0){
stop(paste0("You have a gene with all 0 counts at gene",g));
}
out_amp <- sqrt(beta1^2 + beta2^2);
out_phi <- atan3(as.numeric(beta2), as.numeric(beta1));
ll <- list("out_amp"=out_amp, "out_phi"=out_phi)
}, mc.cores=detectCores())
library(parallel)
lmfit_list <- parallel::mclapply(1:G, function(g)
{
fit <- lm(cycle_data[,g]  ~ sin(cell_times_iter) + cos(cell_times_iter) -1);
sigma[g] <- sd(fit$residuals);
beta1 <- fit$coefficients[1];
beta2 <- fit$coefficients[2];
if(beta1==0 & beta2==0){
stop(paste0("You have a gene with all 0 counts at gene",g));
}
out_amp <- sqrt(beta1^2 + beta2^2);
out_phi <- atan3(as.numeric(beta2), as.numeric(beta1));
ll <- list("out_amp"=out_amp, "out_phi"=out_phi)
}, mc.cores=detectCores())
lmfit_list[[1]]
lmfit_list[[1]]$out_amp
amp <- unlist(lapply(lmfit_list, function(n) return(lmfit_list[[n]]$out_amp)));
amp <- unlist(lapply(1:length(lmfit_list), function(n) return(lmfit_list[[n]]$out_amp)));
amp
amp <- as.numeric(unlist(lapply(1:length(lmfit_list), function(n) return(lmfit_list[[n]]$out_amp))));
amp
amp <- as.numeric(unlist(lapply(1:length(lmfit_list), function(n) return(lmfit_list[[n]]$out_amp))));
lmfit_list <- parallel::mclapply(1:G, function(g)
{
fit <- lm(cycle_data[,g]  ~ sin(cell_times_iter) + cos(cell_times_iter) -1);
sigma[g] <- sd(fit$residuals);
beta1 <- fit$coefficients[1];
beta2 <- fit$coefficients[2];
if(beta1==0 & beta2==0){
stop(paste0("You have a gene with all 0 counts at gene",g));
}
out_amp <- sqrt(beta1^2 + beta2^2);
out_phi <- atan3(as.numeric(beta2), as.numeric(beta1));
ll <- list("out_amp"=out_amp, "out_phi"=out_phi)
}, mc.cores=detectCores())
amp <- as.numeric(unlist(lapply(1:length(lmfit_list), function(n) return(lmfit_list[[n]]$out_amp))));
phi <- as.numeric(unlist(lapply(1:length(lmfit_list), function(n) return(lmfit_list[[n]]$out_phi))));
amp[1]
for(g in 1:G)
{
fit <- lm(cycle_data[,g]  ~ sin(cell_times_iter) + cos(cell_times_iter) -1);
sigma[g] <- sd(fit$residuals);
beta1 <- fit$coefficients[1];
beta2 <- fit$coefficients[2];
if(beta1==0 & beta2==0){
stop(paste0("You have a gene with all 0 counts at gene",g));
}
amp[g] <- sqrt(beta1^2 + beta2^2);
phi[g] <- atan3(as.numeric(beta2), as.numeric(beta1));
}
}
for(g in 1:G)
{
fit <- lm(cycle_data[,g]  ~ sin(cell_times_iter) + cos(cell_times_iter) -1);
sigma[g] <- sd(fit$residuals);
beta1 <- fit$coefficients[1];
beta2 <- fit$coefficients[2];
if(beta1==0 & beta2==0){
stop(paste0("You have a gene with all 0 counts at gene",g));
}
amp[g] <- sqrt(beta1^2 + beta2^2);
phi[g] <- atan3(as.numeric(beta2), as.numeric(beta1));
}
amp[1]
library(devtools)
install_github('kkdey/cellcycleR')
library(cellcycleR)
library(cellcycler)
library(devtools)
install_github('kkdey/cellcycleR')
library(cellcycleR)
library(devtools)
install_github('kkdey/cellcycleR')
library(cellcycleR)
library(devtools)
install_github('kkdey/cellcycleR')
library(cellcycleR)
library(cellcycleR)
library(cellcycler)
remove.packages("cellcycler")
library(cellcycler)
remove.packages("cellcycleR")
install_github('kkdey/cellcycleR')
library(cellcycleR)
install_github('kkdey/cellcycleR')
library(cellcycleR)
G <- 500;
num_cells <- 400;
amp_genes <- rep(10, G);
phi_genes <- runif(G, 0, 2*pi)
sigma_genes <- rchisq(G, 4);
cell_times_sim <- sample(seq(0,2*pi, 2*pi/(num_cells-1)), num_cells, replace=FALSE);
cycle_data <- sim_sinusoidal_cycle(G, amp_genes, phi_genes, sigma_genes, cell_times_sim);
celltime_levels <- 100;
library(devtools)
install_github('kkdey/cellcycleR')
library(cellcycleR)
G <- 500;
num_cells <- 400;
amp_genes <- rep(10, G);
phi_genes <- runif(G, 0, 2*pi)
sigma_genes <- rchisq(G, 4);
cell_times_sim <- sample(seq(0,2*pi, 2*pi/(num_cells-1)), num_cells, replace=FALSE);
cycle_data <- sim_sinusoidal_cycle(G, amp_genes, phi_genes, sigma_genes, cell_times_sim);
celltime_levels <- 100;
out <- cell_ordering_class(cycle_data, celltime_levels = 100, num_iter=100)
library(parallel)
out <- cell_ordering_class(cycle_data, celltime_levels = 100, num_iter=100)
plot(amp_genes, out$amp, col="red",xlab="true amplitudes", ylab="est amplitudes", main="amplitudes est, comparison")
plot(sigma_genes, out$sigma, col="red",xlab="true sigma", ylab="est sigma", main="sigma(variation) est, comparison")
plot(phi_genes, out$phi, col="red",xlab="true phi", ylab="est phi", main="phase est, comparison");
library(plotrix)
library(RColorBrewer)
radial.plot(lengths=1:length(out$cell_times),radial.pos=out$cell_times[order(cell_times_sim)],
line.col=colorRampPalette(brewer.pal(9,"Blues"))(length(out$cell_times)), lwd=2)
radial.plot(lengths=1:length(cell_times_sim),radial.pos=sort(cell_times_sim),
line.col=colorRampPalette(brewer.pal(9,"Blues"))(length(cell_times_sim)), lwd=2)
library(devtools)
install_github('kkdey/cellcycleR')
library(cellcycleR)
G <- 500;
num_cells <- 400;
amp_genes <- rep(10, G);
phi_genes <- runif(G, 0, 2*pi)
sigma_genes <- rchisq(G, 4);
cell_times_sim <- sample(seq(0,2*pi, 2*pi/(num_cells-1)), num_cells, replace=FALSE);
cycle_data <- sim_sinusoidal_cycle(G, amp_genes, phi_genes, sigma_genes, cell_times_sim);
celltime_levels <- 100;
system.time(out <- cell_ordering_class(cycle_data, celltime_levels = 100, num_iter=100))
sessionInfo()
library(devtools)
install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
tmcmcR:::tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain
library(Rcpp)
tmcmcR:::tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain
library(tmcmcR2)
tmcmcR2:::tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain
install_github('kkdey/tmcmcR')
tmcmcR:::tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain
install_github('kkdey/tmcmcR2')
library(tmcmcR2)
tmcmcR2:::tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain
sessionInfo()
version
library(devtools)
install_github('kkdey/maptpx')
install_github('taddylab/maptpx')
install_github('taddylab/maptpx')
library(devtools)
install_github('taddylab/maptpx')
library(devtools)
install_github('taddylab/maptpx')
library(devtools)
install_github('taddylab/maptpx')
library(PMA)
library(cellcycleR)
library(wavethresh)
G <- 100;
num_cells <- 256;
amp_genes1 <- rep(10, G);
phi_genes1 <- rep(c(2,5), each=G/2);
sigma_genes1 <- rchisq(G, 4);
cell_times_sim <- sort(sample(seq(0,2*pi, 2*pi/(num_cells-1)), num_cells, replace=FALSE));
cycle_data <- sim_sinusoidal_cycle(G, amp_genes1, phi_genes1, sigma_genes1, cell_times_sim);
plot(cycle_data[,2], type="l");
plot(cycle_data[,(2+G/2)], type="l")
pmd1 <- PMD(cycle_data, type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
dim(cycle_data)
library(PMA)
library(cellcycleR)
library(wavethresh)
G <- 100;
num_cells <- 256;
amp_genes1 <- rep(10, G);
phi_genes1 <- rep(c(2,5), each=G/2);
sigma_genes1 <- rchisq(G, 4);
cell_times_sim <- sort(sample(seq(0,2*pi, 2*pi/(num_cells-1)), num_cells, replace=FALSE));
cycle_data <- t(sim_sinusoidal_cycle(G, amp_genes1, phi_genes1, sigma_genes1, cell_times_sim));
plot(cycle_data[2,], type="l");
plot(cycle_data[(2+G/2),], type="l")
pmd1 <- PMD(cycle_data, type="standard", K=2, niter=50);
pos1<- apply(pmd1$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd1$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
plot(pmd1$v[,1], type="l")
plot(pmd1$v[,2], type="l")
pos2 <- apply(pmd1$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd1$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
dim(cycle_data)
wave_data <- t(apply(cycle_data, 1, function(x)
{
out <- wd(x, filter.number = 3, family = "DaubExPhase")
return(out$D)
}));
dim(wave_data)
pmd2 <- PMD(wave_data, type="standard", K=2, niter=50);
pos1<- apply(pmd2$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd2$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd2$v[,1], type="l")
plot(pmd2$v[,2], type="l")
pos2 <- apply(pmd2$u, c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd2$u, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
W <- GenW(n=num_cells, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% pmd2$v;
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
rm(list=ls())
data=read.csv("../external_data/Himalayan_grid_matrix.csv",header=TRUE);
counts=as.matrix(data[,-1]);
rownames(counts)=data[,1];
new_data1 <- data.frame(read.csv('../external_data/MohanGrids.csv'));
new_data2 <- data.frame(read.csv('../external_data/MohanGrids2.csv'));
bird_species <- union(as.vector(colnames(counts)), union(as.vector(new_data1[,1]), as.vector(new_data2[,1])));
new_data <- matrix(0,dim(counts)[1]+3,length(bird_species));
new_data[1,match(new_data1[,1],bird_species)]=new_data1[,2];
new_data[2,match(new_data1[,1],bird_species)]=new_data1[,3];
new_data[3,match(new_data2[,1],bird_species)]=new_data2[,2];
new_data[4:(dim(counts)[1]+3),match(colnames(counts),bird_species)]=counts;
new_counts <- as.matrix(new_data);
rownames(new_counts) <- c(c("U1","U2","MA1"),rownames(counts));
colnames(new_counts) <- bird_species;
getwd()
setwd('/Users/kushal/Documents/wave-sfa/project/src/')
data=read.csv("../external_data/Himalayan_grid_matrix.csv",header=TRUE);
counts=as.matrix(data[,-1]);
rownames(counts)=data[,1];
new_data1 <- data.frame(read.csv('../external_data/MohanGrids.csv'));
new_data2 <- data.frame(read.csv('../external_data/MohanGrids2.csv'));
bird_species <- union(as.vector(colnames(counts)), union(as.vector(new_data1[,1]), as.vector(new_data2[,1])));
new_data <- matrix(0,dim(counts)[1]+3,length(bird_species));
new_data[1,match(new_data1[,1],bird_species)]=new_data1[,2];
new_data[2,match(new_data1[,1],bird_species)]=new_data1[,3];
new_data[3,match(new_data2[,1],bird_species)]=new_data2[,2];
new_data[4:(dim(counts)[1]+3),match(colnames(counts),bird_species)]=counts;
new_counts <- as.matrix(new_data);
rownames(new_counts) <- c(c("U1","U2","MA1"),rownames(counts));
colnames(new_counts) <- bird_species;
bodymass_data <- read.csv('../external_data/massKushal.csv');
bodymass_val <- bodymass_data[,2];
bodymass_birds <- bodymass_data[,1];
bodymass_matched <- bodymass_data[match(bird_species,bodymass_birds),2];
new_counts_sorted <- new_counts[, order(bodymass_matched, decreasing = TRUE)];
padded_counts <- t(apply(new_counts_sorted, 1, function(x)
{
y=x;
length(y)<-512;
y[is.na(y)]<-0
return(y)
}))
padded_data <- log((padded_counts+0.5))
dim(padded_data)
library(wavethresh)
wave_data <- t(apply(padded_data[-(1:3),], 1, function(x)
{
out <- wd(x, filter.number = 3, family = "DaubExPhase")
return(out$D)
}));
dim(wave_data)
library(PMA)
pmd2 <- PMD(wave_data, type="standard", K=2, niter=50);
metadata=read.csv("../external_data/Himalayan_grid_metadata.csv",header=TRUE);
elevation_metadata=metadata$Elevation[match(rownames(padded_data[-(1:3),]),metadata[,1])];
east_west_dir = metadata$WorE[match(rownames(padded_data[-(1:3),]),metadata[,1])];
pos1<- apply(pmd2$v, c(1,2), function(x) return (max(x,0)))
neg1 <- apply(pmd2$v, c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos1), col=2:3)
barplot(t(neg1), col=2:3, add=TRUE)
plot(pmd2$v[,1], type="l")
plot(pmd2$v[,2], type="l")
pos2 <- apply(pmd2$u[order(elevation_metadata),], c(1,2), function(x) return (max(x,0)))
neg2 <- apply(pmd2$u[order(elevation_metadata),], c(1,2), function(x) return (min(x,0)))
par(mar=c(12,2,2,1))
barplot(t(pos2), col=2:3)
barplot(t(neg2), col=2:3, add=TRUE)
W <- GenW(n=512, filter.number=3, family="DaubExPhase")
idwt <- W[,-1] %*% pmd2$v;
plot(idwt[,1], type="l")
plot(idwt[,2], type="l")
data <- read.table("../external_data/Botstein_data/botstein_cdc.txt", sep="\t", header=TRUE, fill=TRUE);
cdc_data <- data[,grep("elu",colnames(data))];
fillNAgaps <- function(x, firstBack=FALSE) {
## NA's in a vector or factor are replaced with last non-NA values
## If firstBack is TRUE, it will fill in leading NA's with the first
## non-NA value. If FALSE, it will not change leading NA's.
# If it's a factor, store the level labels and convert to integer
lvls <- NULL
if (is.factor(x)) {
lvls <- levels(x)
x    <- as.integer(x)
}
goodIdx <- !is.na(x)
# These are the non-NA values from x only
# Add a leading NA or take the first good value, depending on firstBack
if (firstBack)   goodVals <- c(x[goodIdx][1], x[goodIdx])
else             goodVals <- c(NA,            x[goodIdx])
# Fill the indices of the output vector with the indices pulled from
# these offsets of goodVals. Add 1 to avoid indexing to zero.
fillIdx <- cumsum(goodIdx)+1
x <- goodVals[fillIdx]
# If it was originally a factor, convert it back
if (!is.null(lvls)) {
x <- factor(x, levels=seq_along(lvls), labels=lvls)
}
x
}
cdc_data <- cdc_data[rowSums(is.na(cdc_data)) < (dim(cdc_data)[2] - 4),];
cdc_data_mod <- t(apply(cdc_data, 1, function(x) fillNAgaps(x, firstBack = TRUE)));
cycle_data <- cdc_data_mod;
dim(cycle_data)
cycle_data_norm <- apply(cycle_data,1,function(x)  return (x-mean(x))/sd(x))
cycle_data_norm <- cycle_data_norm[, -which(colSums(cycle_data_norm)==0)]
dim(cycle_data_norm)
